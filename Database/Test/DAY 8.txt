		
							DAY 8 
							
			REVISION :- 
				
				HISTORY DATABASE
				DATA STORES IN THE DATABASE
				CODD'S RULES
				CATEGORIES
					DQL
					DML
					DDL
					DCT
					DTL
				SELECT 
					FROM 
						WHERE
							GROUP BY 
								HAVING 
									ORDER BY 
										LIMIT 
										
				FUNCTIONS :
					NUMERIC 
					STRING
					DATE 
					AGGREGATED 
					
				JOIN 
					INNER JOIN
					OUTER JOIN
					SELF JOIN
					NATURAL JOIN
					CROSS JOIN 
					
				SUB QUERIES 
				CORRELATED QUERIES 
				
				INDEX 
				
				VIEWS 
					INSERT
					UPDATE 
					DELETE 
					SELECT 
					
				EXECUTION PLAN 
				
				
=======================================================================

PROGRAMING : 
		PLSQL 
			PROGRAMMING LANGUAGE IN MYSQL 
			
			
		BLOCKS: 
			SET OF CODE WRITTEN AND STORED IN THE DATABASE 
			
			WRITTEN ONCE AND USED MULTIPLE TIME 
			
			PART OF MY DATABASE, THEY ONLY REMOVES 
					WHEN SOMEBODY PERSONALY DELETE THEM FROM THE DATABASE 
			
			BLOCKS:- 
			
				THREE KEY WORDS 
					
					BEGIN : INDICATE THE STARTING POINT OF THE BLOCK
					
					DECLARE : ALLOWS USER TO DECLARE THE VARIABLES IN THE SYSTEM 
					SCOPE OF THESE VARIABLES ARE WITH IN THE BLOCK 
					
					END : INDICATE THE END OF THE BLOCK 
					
			IN MYSQL : 
					EVERY BLOCK OR DEFINATION OF EVERY BLOCK 
					
					NAMED AS 
					EITHER 
						PROCEDURES :
							SET OF CODE WHICH DO NOT RETURN ANY VALUE 
							
							CALLING PROCEDURE 
							
							- CALL PROCEDURENAME 
						
						FUNCTIONS :
							SET OF CODE WHICH RETURN A DATATYPE 
							
							CALLING OF FUNCTIONS 
							
							SELECT FUNCTIONAME; 
							
							
			DIFFERENCE BETWEEN PROCEDURES AND FUNCTIONS 

				1) PROCEDURE ARE NOT DESIGNED TO RETURN VALUE 
					THEY ARE DESIGNED TO EXECUTE SET OF CODE 
					
				WHERE AS 
				
					FUNCTIONS ARE ALWAYS RETURN THE VALUE (DATATYPE)
					
				2) PROCEDURE CAN BE ECECUTED BY A KEYWORD CALL 
					
					USER CAN NOT USE PROCEDURE IN THE SELECT STATEMENT 
					
				WHERE AS 
				
					FUNCTION THAT THEY ALWAYS A PART OF SELECT STATEMENT 
					
					
PROCEDURES : 
					
	SYNTAX : 
				CREATE PROCEDURE PROCEDURENAME()
				BEGIN
				
				STATEMENTS ......
				
				END;
				
				IF SOME VARIABLES ARE THE PART OF PROCEDURE 
				
				CREATE PROCEDURE PROCEDURENAME()
				BEGIN
				
				DECLARE 
				VARIABLE DEFINATIONS...
				
				STATEMENTS ......
				
				END;				
					
					
				CALL PROCEDURENAME;

P1 : 
		FETCH ALL THE RECORDS OF THE EMPLOYEE TABLE 
		
			SELECT * FROM EMPLOYEES;
			
			CREATE PROCEDURE DAC1()
			BEGIN
			
			SELECT * FROM EMPLPOYEES;
			
			END;
			
			
		SYSTEM ALLOWS : 
			CHANGE THE DELIMITER OF MY CONSOLE FROM WHERE WE ARE EXECUTING THE PROCEDURE OR FUNCTIONS ......
			
			DELIMITER //
			
			CREATE PROCEDURE DAC1()
			BEGIN
			
			SELECT * FROM EMPLPOYEES;
			
			END;
			
			DELIMITER ;
			
			CALL DAC1;
			
			
			------------------
			AT ANY POINT OF TIME, IF I NEED TO CHANGE THE PROCEDURE DEFINATION 
			
			DROP PROCEDURE 
			
			CREATE IT AGAIN 
			
		- DROP A PROCEDURE 
			DROP PROCEDURE PROCEDURENAME;
			
			
			DELIMITER //
			DROP PROCEDURE DAC1 //
			
			CREATE PROCEDURE DAC1()
			BEGIN
			
			SELECT EMPLOYEE_ID, CONCAT(FIRST_NAME,' ',LAST_NAME) AS NAME FROM EMPLOYEES;
			
			END //
			
			DELIMITER ;
			
	-----------------------------------------------------------------

		ORACLE : 
		
				CREATE OR REPLACE PROCEDURE PROCEDURENAME()
				BEGIN
				END;
				
	------------------------------------------------------------------

		NEED TO VIEW THE DEFINATION OF THE PROCEDURE OR FUNCTION OR TABLE,,,,
		
		SHOW CREATE PROCEDURE PROCEDURENAME;
		
		SHOW CREATE FUNCTION FUNCTIONNAME;
		
		SHOW CREATE TABLE TABLENAME;
		
	-------------------------------------------------------------------


** 
	HOW CAN I STORE THE VALUE IN THE VARIABLES ...
	
	BASICALY - SIGNLE OUTPUT OF THE QUERY NEED TO STORED IN THE VARIABLE 
	
		SELECT COUNT(*) FROM EMPLOYEES; 
		
		
	AS DATABASE ALLOWS TO STORE THE OUTPUT OF THE QUERY WITH SINGLE VALUE IN THE VARIABLE - 
		IT CHANGE THE SYNTAX OF SELECT ONLY FOR 
				BLOCKS 
				
		SELECT COUNT(*) INTO VARIABLENAME FROM EMPLOYEES;
		
	----------------------------------------------------------
DAC2 : 
		DELIMITER //
		
		DROP PROCEDURE IF EXISTS DAC2 //
		
		CREATE PROCEDURE DAC2()
		BEGIN
		
		DECLARE X INT;  -- DEFINCATION OF DECLARING A VARIABLE 
		
		SELECT COUNT(*) INTO X FROM EMPLOYEES;
		
		SELECT X;
		
		END //
		
		DELIMITER ;
		
	-----------------------------------------------------------
	
	NEED TO PUSH MULTIPLE VALUES INTO THE VARIABLES :
	
	
	SELECT COUNT(*), MAX(SALARY) FROM EMPLOYEES; 
	
	+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	
DAC3 :- 
	
	DELIMITER //
	
	CREATE PROCEDURE DAC3()
	BEGIN 
	
	DECLARE X INT;
	DECLARE Y INT;
	
	SELECT COUNT(*), MAX(SALARY) INTO X,Y FROM EMPLOYEES;
	
	SELECT X AS TEMPLOYEES,Y AS MAXSALARY;
	
	END //
	
	DELIMITER ;
	
---------------------------------------------------------------------	
	
METHODS WITH OR WITHOUT PARAMTERS 

CONCEPT OF PARAMETRIZED PROCEDURES OR FUCNTIONS...


		PARAMETERS ARE DEFINED IN THE DATABASE WITH THREE KEY WORDS 
		
		IN 
			: DEFAULT DEFINATION OF THE PARAMETER 
			: INPUT TYPE 
			THESE VARIABLE ALWAYS USED ON THE RIGHT SIDE OF EQUALS TO OPERATOR 
				
				X =20 
				
				X : TYPE OF VARIABLE WHICH ACCEPT THE VALUE 
				20 : VALUE 
			DEFAULT ALL VARIBALE ARE IN VARIBLES 
			
			
		OUT :
			
			NEED TO STORE THE VALUES INSIDE THE BLOCK
			VALUES INTO THE VARIABLE 
				THOSE VARIABLE NEED TO DEFINED AS OUT 
				** POINTERS	

					X = 40; 
					
		INOUT :
			IN AND OUT 
				THEY BEHAVE BOTH WAYS 
					THEY ACCEPT THE VALUE AND TREAT AS INPUT VARIBALE 
					
					
					X = X + 1
					
			
	--------------------------------------------------------

		SYNTAX FOR PARAMETRIZED PROCEDURE 
		
			CREATE PROCEDURE PREOCEDURENAME(PARAMETERS DATATYPE)
			BEGIN
			END;
			
DAC4 : 
		TRY TO PRINT ALL THE EMPLOYEES SALARIES BELONGS TO RANDOM DEPARTMENT  
		
		
		DELIMITER //
		
		CREATE PROCEDURE DAC4(X INT)
		BEGIN 
		
		SELECT CONCAT(FIRST_NAME,' ',LAST_NAME) NAME, SALARY 
			FROM EMPLOYEES 
				WHERE DEPARTMENT_ID = X;
		
		END //
		
		DELIMITER ;
		
		CALL DAC4(20);
		
----------------------------------------------------------------------

RETURN VALUE FROM PROCEDURE : PARAMETER AS AN OUT 


DAC5 : 
	WHERE I NEED TO RETURN MAXIMUM SALARY OF THE DEPARTMENT 
	
		
	DELIMITER // 
	
	CREATE PROCEDURE DAC5(X INT,OUT MAXS INT)
	BEGIN 
	
	SELECT MAX(SALARY) INTO MAXS FROM EMPLOYEES
			WHERE DEPARTMENT_ID = X;
			
	END //
	
	DELIMITER ;
			
	CALL DAC5(20,@Y);
----------------------------------------------------------------	

** INOUT 

	ADDING TWO VALUES AND RETURN THE OUTPUT 
	
		DELIMITER //
		
		CREATE PROCEDURE DAC6(X INT, INOUT Z INT)
		BEGIN
		
		SET Z = Z + X;
		
		END //
		
		DELIMITER ;
		
mysql> CALL DAC6(20,30);
ERROR 1414 (42000): OUT or INOUT argument 2 for routine humanresource12.DAC6 is not a variable or NEW pseudo-variable in BEFORE trigger
mysql> SET @Y = 30;
Query OK, 0 rows affected (0.00 sec)

mysql> CALL DAC6(20,@Y);
Query OK, 0 rows affected (0.00 sec)		
		
INOUT TYPE OF VARIABLES IN THE PROGRAM :::::::::::::

IN , OUT RETURN VALUE 

-----------------------------------------------------------------------

NEXT :- 

	CONDITIONAL OPERATORS TO HANDLES THE CONDITION
	
	1) IF ELSE END ... 
	
		SYNTAX : 
				
				IF EXPRESSION THEN 
					STATEMENT;  -- EXECUTED WHEN EXPRESSION IS TRUE 
				ELSE 
					STATEMENT; -- EXECUTED WHEN EXPRESSION IS FALSE 
				END IF;
				
				
	2) MULTIPE COMPARISONS : 
		
			IF EXPRESSSION THEN 
				STATEMENT;
			ELSEIF EXPRESSION THEN 
				STATEMENT;
			ELSE 
				STATEMENT;
			END IF;
				
DAC7 : 
		NEED TO PRINT BELOW EXPECTED STATEMENTS : 
			1) PROCEDURE ACCEPT THE EMPLOYEE ID AS INPUT PARAMERTER
			2) BASED ON THE SALARY OF THE EMPLOYEE - DEFINE THE LEVEL
			
			SALARY > 15000 (HIGHLY PAID)
			SALARY < 15000 AND SALARY > 10000 (BENCHMARK EMPLOYEE)
			SALARY < 10000 (LOW PAY GRADE)
				
		
		* PROCEDURE NEED TO WORK FOR ANY EMPLOYEES (EMPLOYEE ID NEED TO DYNAMIC) 
			
			
		DELIMITER //
		
		DROP PROCEDURE IF EXISTS DAC7 //
		
		CREATE PROCEDURE DAC7(X INT, OUT LEVEL VARCHAR(100))
		BEGIN
		
		DECLARE SAL INT;
		
		SELECT SALARY INTO SAL FROM EMPLOYEES
			WHERE EMPLOYEE_ID = X;
		
		IF SAL > 15000 THEN 
			SET LEVEL = 'HIGHLY PAID';
		ELSEIF SAL > 10000 AND SAL < 15000 THEN 
			SET LEVEL = 'BENCHMARK EMPLOYEE';
		ELSE
			SET LEVEL = 'LOW PAY GRADE';
		END IF;
		
		END //
		
		DELIMITER ;
		
------------------------------------------------------------------

2) CASE : 

			SELECT CASE STATEMENT END FROM TABLENAME;
			
			CASE 
				WHEN CONDITION THEN STATEMENT;
				WHEN CONDITION THEN STATEMENT;
				.
				.
				.
				.
				.
				.
				ELSE STATEMENT;
			END CASE;

-----------------------------------

DAC8 : 
		NEED TO SPELL THE NUMBER ENTER TO THE PROGRAM 
			FROM 1 TO 10 
			
		
		DELIMITER //
		
		CREATE PROCEDURE DAC8(X INT)
		BEGIN 
		
			CASE X 
				WHEN 1 THEN SELECT 'ONE';
				WHEN 2 THEN SELECT 'TWO';
				WHEN 3 THEN SELECT 'THREE';
				WHEN 4 THEN SELECT 'FOUR';
				WHEN 5 THEN SELECT 'FIVE';
				WHEN 6 THEN SELECT 'SIX';
				WHEN 7 THEN SELECT 'SEVEN';
				WHEN 8 THEN SELECT 'EIGTH';
				WHEN 9 THEN SELECT 'NINE';
				WHEN 10 THEN SELECT 'TEN';
				ELSE SELECT 'OUT OF BOUNDRY';
			END CASE;
		
			END //
			
			DELIMITER ;
			


----------------------------------------------------------------
DAC9 : 

		DELIMITER //
		
		DROP PROCEDURE IF EXISTS DAC9 //
		
		CREATE PROCEDURE DAC9(X INT, OUT LEVEL VARCHAR(100))
		BEGIN
		
		DECLARE SAL INT;
		
		SELECT SALARY INTO SAL FROM EMPLOYEES
			WHERE EMPLOYEE_ID = X;
		
		CASE 
		WHEN SAL > 15000 THEN SET LEVEL = 'HIGHLY PAID';
		WHEN SAL > 10000 AND SAL < 15000 THEN SET LEVEL = 'BENCHMARK EMPLOYEE';
		ELSE SET LEVEL = 'LOW PAY GRADE';
		END CASE;
		
		END //
				
		DELIMITER ;


--------------------------------------------------------------------

NOW SIMILAR TO ALL OTHER PROGRAMS : 

		* VARIABLE 
		* PARAMETRIZED PROCEDURES 
				IN, OUT 
		* HOW TO MOVE THE VALUES FROM SELECT TO THE VARIABLE 
		* DECLARE THE VARIABLE 
		* CONDITINS INSIDE THE PROGRAM 
				IF ELSE 
				CASE 
				
	LOOPS : 
			NEED TO EXCUTE THE SAME SET OF CODE MULTIPLE TIME BASED ON THE VALUES...
			
	1) WHILE LOOP : BREAK POINT OF THE LOOP 

		SYNTAX : 
			
				WHILE EXPRESSION/CONDITION DO 
						STATEMENTS.....
						
					BREAK POINT........					
				END WHILE; 
			
			
	TAKE AN EXAMPLE OF FIBONACCI SERIES 
		
			0 , 1 , 1, 2, 3, 5, 8, 13........
			
			FNUM = 0 
			SNUM = 1 
			
			THEN 
			
			TNUM = FNUM + SNUM;
			FNUM = SNUM;
			SNUM = TNUM;
			
		DELIMITER //

		DROP PROCEDURE IF EXISTS DAC10 // 
		
		CREATE PROCEDURE DAC10(X INT)
		BEGIN 
		
		DECLARE FNUM INT DEFAULT 0;
		DECLARE SNUM INT DEFAULT 1;
		DECLARE TNUM INT;
		
		DECLARE FSERIES VARCHAR(200);
		
		SET FSERIES = CONCAT(FNUM,' ,',SNUM); -- FSERIES = 0,1
		
		WHILE X > 2 DO 
		
			SET TNUM = FNUM + SNUM;
			SET FNUM = SNUM;
			SET SNUM = TNUM;
			
			SET FSERIES = CONCAT(FSERIES,' ,',TNUM);
			
			SET X = X - 1;
			
		END WHILE;
		
		SELECT FSERIES;
		
		END //
		
		DELIMITER ;
		--------------------------
		CALL DAC10(34);
			
			
==============================================================

ANOTHER : 

	LOOP 
		DEFINATION 
		
			NAME1 : LOOP 
			
				LEAVE NAME1;	BREAK POINT 		

			END LOOP NAME1 
			
	EXAMPLE - AFTER VIEWING ANOTHER CONCEPT 
	
-----------------------------------------------------------------

WE CAN WORK WITH THE SELECT STATEMENT WHICH RETURN SINGLE VALUES ...

	NOW IF I NEED TO WORK ON COMPLETE TABLE VALUES OR SET OF VALUES 
		OR SET OF ROWS ....
		
		HOW CAN WE USE THIS IN THE PROGRAMMING LANGUAGE 
		
		
		
		SELECT COLUMN INTO VARIABLE FROM TABLE ......
		
		
CURSORS : 
		HAVING A CAPABLITY TO TRAVERSE IN THE MULTIPLE ROWS OR VALUE 
		TRAVERSE IN THE SET OF VALUE 
		
		INTERNALLY : 
			CURSORS ARE THE POINTERS 
				WHICH HOLDS THE ADDRESS OF THE ROWS 
					AND TRAVERSE BASED ON THE CONCEPT 
					
			
			SELECT EMPLOYEE_ID, SALARY FROM EMPLOYEES WHERE DEPARTMENT_ID = 20;
			
			
			+-------------+----------+
			| EMPLOYEE_ID | SALARY   |
			+-------------+----------+
CURSOR ---> |         201 | 13000.00 |
			|         202 |  6000.00 |
			+-------------+----------+
			
			
			CURSORS : CAN ONLY BE DEFINED BY THE SELECT 
			
			
			CURSORS : TWO KEYWORDS 
			----- 
			CURSOR DECLARATION 
				1) OPEN 
				2) FETCH 
				
	CURSORS : ARE ALWAYS DECLARED BY THE SELECT STATEMENT ....

		SYNTAX : 
		
		DECLARE CURSORNAME CURSOR 
				FOR SELECT STATEMENT;
				
		
		DECLARE EMP_CUR	CURSOR 
				FOR SELECT EMPLOYEE_ID, SALARY FROM EMPLOYEES WHERE DEPARTMENT_ID = 20;
				
		** OPEN EMP_CUR;
				** GOES AND CHECK THE DEFINATION ATTACHED TO THE CURSOR 
				** EXECUTE THE SELECT STATEMENT  AND CREATE THE OUTPUT IN THE TEMP MEMORY 
				** EMP_CUR - START POINTING TO THE FIRST ROW OF THE OUTPUT 
				
		** FETCH : TO FETCH ONE BY ONE ALL THE ROWS OF THE CURSOR POINTING 
			
				** USED TO TRAVERSE THE SET OF THE VALUES 
					CURSOR VALUE 
				
				SYNTAX : 
				
					FETCH CURSORNAME INTO VARIBALES.....

--------------------------------------------------------------------

DAC11 : 
			FIND ALL THE EMPLOYEES NAME, EMPLOYEE ID AND THEIR SALARY AND INCREMENTED SALARY WITH 15% 
			
			NEED TO PRINT 
				EMPLOYEE_ID 
				EMPLOYEE_NAME 
				OLD SALARY 
				NEW SALARY 
		
		
		DELIMITER // 
		
		DROP PROCEDURE IF EXISTS DAC11 //
		
		CREATE PROCEDURE DAC11()
		BEGIN 
		DECLARE EID INT;
		DECLARE FNAME VARCHAR(50);
		DECLARE SAL INT;		
		DECLARE BCOUNT INT;  -- TOTAL NUMBER OF ROWS
		DECLARE EMP_CUR CURSOR
			FOR SELECT EMPLOYEE_ID,FIRST_NAME,SALARY FROM EMPLOYEES;
			
		SELECT COUNT(*) INTO BCOUNT FROM EMPLOYEES;
		
		CREATE TEMPORARY TABLE EMPSAL(
			ID INT,NAME VARCHAR(100),OLDSAL INT,NEWSAL INT);			
		
		OPEN EMP_CUR; -- FIRST STEP TO EXECUTE THE CURSOR DEFINATION
			
		L_LEVEL : LOOP  -- NAMED THE LOOP AS L_LEVEL, THIS START POINT
		
			IF BCOUNT <=0 THEN   -- EXIT CRITERIA 
				LEAVE L_LEVEL;
			END IF;
			
			FETCH EMP_CUR INTO EID,FNAME,SAL;
			
			--  FETCH FIRST ROW
			-- FIRST ROWS REMOVES FROM THE TEMP 
			-- CURSOR START POINTING TO THE NEXT ROW...
			
			INSERT INTO EMPSAL VALUES(EID,FNAME,SAL,SAL*1.15);
			
			SET BCOUNT = BCOUNT - 1;  -- COUNTER 
		END LOOP L_LEVEL;
		
		CLOSE EMP_CUR;
		
		SELECT * FROM EMPSAL;
		
		DROP TABLE EMPSAL;
		END //
		
		DELIMITER ;
		
		
			
			
			
			
			
========================================

			+-------------+----------+
			| EMPLOYEE_ID | SALARY   |
			+-------------+----------+
CURSOR ---> |         201 | 13000.00 |
			|         202 |  6000.00 |
			+-------------+----------+		
			
			
			FETCH CURSOR INTO X , Y 
				X = 201 AND Y = 13000 
				
			+-------------+----------+
			| EMPLOYEE_ID | SALARY   |
			+-------------+----------+
CURSOR --->	|         202 |  6000.00 |
			+-------------+----------+			
				
			FETCH CURSOR INTO X , Y 
				X = 202 AND Y = 6000 
		
			+-------------+----------+
			| EMPLOYEE_ID | SALARY   |
			+-------------+----------+
CURSOR --->	+-------------+----------+	
				
			FETCH CURSOR INTO X , Y 
			IT WILL TROW EXCEPTION 
				NULL POINTER 
				
=-================================================

CURSOR : 

			IS THE POINTER 
			WHICH ALWAYS WORK ON THE DEFINATION 
				DEFINATION : SELECT STATEMENT 
				
			FOUR STPES INVOLVED : 
				1) DEFINATION OF THE CURSOR 
					* DEFINATION OF THE CURSOR NEED TO BE DEFINED AFTER ALL OTHER VARIABLE DECLARED 
					
				DECLARE CURSORNAME CURSOR 
					FOR SELECT QUERY;
					
				2) OPEN CURSORNAME;
					* EXECUTE THE SELECT STAEMENT ATTACHED TO THE CURSOR 
					* CREATE A TEMP TABLE WITH THE OUTPUT 
					* NAME OF THE CURSOR START POINTING TO THE FIRST ROW OF THE TEMP TABLE 
					
				3) FETCH CURSORNAME INTO VARIABLES 
					* FETCH THE POINTED ROW INTO THE RESPECTIVE VARIABLES
					* REMOVE THAT RECORD FROM THE TEMP TABLE 
					* CURSORNAME START POINTING TO THE NEXT RECORD
					
					** USE THIS FETCH INSIDE THE LOOP 
					
				4) CLOSE CURSOR
					* TO WIPES USED SPACE 
					
					
----------------------------------------------------------------------

1) WHEN ALL THE ROWS FETCHED FROM THE CURSOR 
						AND AGAIN I AM FETCH ANOTER 
							WHEN CURSOR IS EMPTY 
							
				SYSTEM THROWS THE EXCEPTION 
				
				'NOT FOUND' 
				
	SYSTEM ALLOWS US TO HANDLE THE EXCEPTION THROWS IMPLICITLY OR EXPLICITY IN THE PROGRAM 
	
		TRY {
		
		
		
		} CATCH(EXCEPTION E) 
			{
			LINES OF CODE 
			}
		
		FINALIZE {
				ALWAYS EXECUTED 
			}
					
** WHEN CURSOR REACHED IN THE LAST LINE 
					IT THROWS A EXCEPTION  'NOT FOUND'
					
		HANDLE THAT EXCEPTION 
		
		SYSTEM : EXCEPTION HANDLING IN PLSQL 
		
			1) DECLARE THE EXCEPTION 
				
				SYNTAX : 
					
			DECLARE ACTION HANDLER FOR CONDITION STATEMENTS;

				DECLARE : KEYWORD TO DECLARE THE VARIABLES AND HANDLERS
				
				ACTION : EXIT , CONTINUE
				
					EXIT : WHENEVER YOU GET AN EXCEPTION IN THE PROGRAM 
							HANDLE IT AND MOVE OUT FROM THE PROGRAM 
								
					CONTINUE : WHENEVER YOU GEN AN EXCEPTION IN THE PROGRAM 
						HANDLE IT AND CONTINUE WITH THE PROGRAM 
						
				HANDLER FOR : KEY WORDS 

				CONDITIONS : 
							NOT FOUND 
							SQLEXCEPTION
							SQLWARNING
							.....
				STATEMENTS : HANDLING PART 			
							

PROGRAM TO EXIT FROM THE BLOCK AFTER HANDLING THE EXCEPTION: 

---- SAME PREVIOUS EXAMPLE 

		DELIMITER //
		
		DROP PROCEDURE IF EXISTS DAC12 //
						
		CREATE PROCEDURE DAC12()
		BEGIN 
			DECLARE EID INT;
			DECLARE FNAME VARCHAR(50);
			DECLARE SAL INT;
			DECLARE V_FINISH INT DEFAULT 0;
			DECLARE EMP_CUR CURSOR 
				FOR SELECT EMPLOYEE_ID,FIRST_NAME,SALARY FROM EMPLOYEES;
			DECLARE EXIT HANDLER FOR NOT FOUND SET V_FINISH = 1;

			CREATE TEMPORARY TABLE EMPTEMP(ID INT,NAME VARCHAR(200),OSAL INT,NSAL INT);
			
			OPEN EMP_CUR;
			
			L_LEVEL : LOOP 
				
				IF V_FINISH = 1 THEN 
					LEAVE L_LEVEL;
				END IF;
			
			FETCH EMP_CUR INTO EID,FNAME,SAL;
			
			INSERT INTO EMPTEMP VALUES(EID,FNAME,SAL,SAL*1.15);
		
			END LOOP L_LEVEL;
			
			CLOSE EMP_CUR;
			
			SELECT * FROM EMPTEMP;
			
			DROP TABLE EMPTEMP;
			
			END //
			
			DELIMITER ;
		
---------------------------------------------------------------------

PROGRAM WITH CONTINUE : 

DELIMITER //
		
		DROP PROCEDURE IF EXISTS DAC12 //
						
		CREATE PROCEDURE DAC12()
		BEGIN 
			DECLARE EID INT;
			DECLARE FNAME VARCHAR(50);
			DECLARE SAL INT;
			DECLARE V_FINISH INT DEFAULT 0;
			DECLARE EMP_CUR CURSOR 
				FOR SELECT EMPLOYEE_ID,FIRST_NAME,SALARY FROM EMPLOYEES;
			DECLARE CONTINUE HANDLER FOR NOT FOUND SET V_FINISH = 1;

			CREATE TEMPORARY TABLE EMPTEMP(ID INT,NAME VARCHAR(200),OSAL INT,NSAL INT);
			
			OPEN EMP_CUR;
			
			L_LEVEL : LOOP 
			
				FETCH EMP_CUR INTO EID,FNAME,SAL;
				
				IF V_FINISH = 1 THEN 
					LEAVE L_LEVEL;
				END IF;
			
			INSERT INTO EMPTEMP VALUES(EID,FNAME,SAL,SAL*1.15);
		
			END LOOP L_LEVEL;
			
			CLOSE EMP_CUR;
			
			SELECT * FROM EMPTEMP;
			
			DROP TABLE EMPTEMP;
			
			END //
			
			DELIMITER ;		
		
		
	==============================================================	
		
		ORACLE : 
			DDL COMMANDS NOT ALLOWED IN THE BLOCKS 
			
				BLOCKS : PRACODEURES/ FUNCTIONS 
				
				
		

		
		
		
		
		
		
		
		
		
				
		











	
				
				
				
				
				
				
				
				
		
		
		
		
		
		
		
		
		
		
	
				
			
			
			
			
			
			
			
			
			
			
				
					
							
							
						
						
					
					
					
					
					
					
					
					
					
					
					
					
					

















					
					
					
					
					
					
				
				
				
				
				
				
				
				
				
				